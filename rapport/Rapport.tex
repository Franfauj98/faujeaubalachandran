\documentclass[12pt,a4paper]{article}
%police
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\usepackage[tc]{titlepic}

\usepackage{longtable}
\usepackage{adjustbox}
\usepackage{graphicx}
\usepackage{layout}
\usepackage{fancyhdr}
\usepackage{eurosym}
\usepackage{multirow}
\usepackage{float}
\usepackage[normalem]{ulem}

\usepackage{hyperref}

\usepackage{geometry}
\geometry{margin=1.2in}

\pagestyle{fancy}
\fancyhead{}
\renewcommand{\headrulewidth}{0pt}
\lfoot{PLT - BALACHANDRAN Chirojean - FAUJEAU François}
\cfoot{}
\rfoot{\thepage}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\includegraphics[width=0.5\textwidth]{Logo_ENSEA.jpg} 
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.57\textwidth}
\begin{flushright} \large
FAUJEAU François \textsc{} \\
BALACHANDRAN Chirojean\textsc{} \\
3A IS\textsc{} \\
\end{flushright}
\end{minipage}\\[1cm]

\centering

\HRule \\[0.5cm]
{ \huge \bfseries PROJET CIVILIZATION}\\[0.3cm]% Title of your document
Rapport du projet logiciel transversal \textsc{} \\[0.5cm]
\HRule \\[3cm]

\includegraphics[width=1\textwidth]{ressources/map.png}\\[3.5cm]


\begin{flushleft}
Année scolaire: 2018-2019
\end{flushleft}
\end{titlepage}


\newpage

\tableofcontents
\thispagestyle{empty}
\setcounter{page}{0}

\newpage

\section{Présentation générale}

\subsection{Archétype}

Le but de notre projet logiciel transversal est de créer une version très simplifiée du jeu civilization. Ce jeu est un jeu de stratégie tour par tour où l'objectif d'un joueur est de développer un empire en choississant une civilisation au choix parmi plusieurs. 

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\textwidth]{civ3.png}
     \caption{Image d'un gameplay de civilization 3}
\end{figure}

\subsection{Règles du jeu}

Le but pour chaque joueur est de développer un empire avec la civilisation romaine. Pour cela, le joueur doit améliorer et gérer ses ressources (mines d'or, terres agricoles) ainsi que ses bâtiments (caserne et palais). \\
Nous avons choisi que chaque joueur pourrait seulement utiliser la civilisation romaine. Chaque empire permet de créer différents bâtiments : 
\begin{enumerate}
    \item Le palais : bâtiment principal de l'empire. Son niveau correspond au niveau de l'empire. Plus sont niveau est élevé et plus il est possible d'améliorer les autres bâtiments et unités.
    \item La caserne : permet de former des soldats. Quand le niveau de la caserne augmente, le niveau des troupes formées et le nombre des troupes qui peuvent être formées augmentent. Il y aura quatre types d'unités de combat : un cavalier, un épéiste, un archer et une catapulte. A la création d'une unité, le joueur choisira si elle est créée pour défendre l'empire ou si elle peut se déplacer sur la carte de jeu.
    \item Ressources : le joueur possèdera trois types de ressources à savoir les mines d'or, la réserve de bois et les terres agricoles. Quand le niveau d'une ressource augmente, la capacitée de stockage de cette ressource et la quantité produite sont augmentées.
\end{enumerate}
Pour améliorer les bâtiments, il faudra que le joueur dépense une certaine quantité de bois et d'or et pour la formation de soldats une certaine quantité de récoltes agricoles et d'or.\\
Pour développer son empire plus rapidement il est possible d'en combatre un autre (détenu soit par l'IA, soit par un joueur) ou de s'en défendre. En effet, en cas de victoire l'empire victorieux reçoit une partie des ressources de l'empire adverse et un bonus de victoire. L'empire qui a perdu recupère, lui, un faible bonus de défaite. \\Le système de combat est le suivant. 
Chacun leur tour, les joueurs pourront décider de : 
\begin{itemize}
    \item se déplacer pour se rapprocher du combat.
    \item choisir qu'un soldat en attaque un autre s'il est dans sa zone d'action.
\end{itemize}
Un combat se termine lorsque tous les soldats d'un joueur sont éliminés. 
\\Dans notre jeu, un tour correspond à une action: une amélioration de bâtiment, la formation d'une unité, son déplacement.\\

\subsection{Ressources}

Voici les différentes ressources (images, textures, sprites) utilisées pour le développement du jeu. Pour créer les cartes de jeu nous les génèrerons de manière aléatoire en mode isométrique. Ces cartes sont des cartes de jeu 25 x 25.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\textwidth]{ressources/cities2.png}
     \caption{Bâtiments de la civilisation romaine en fonction des niveaux}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\textwidth]{ressources/Terrain.png}
     \caption{textures pour la création de la map}
\end{figure}
\newpage
\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\textwidth]{ressources/ocean.png}
     \caption{textures pour la mer sur la map}
\end{figure}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\textwidth]{ressources/Units.png}
     \caption{images des unités de combats}
\end{figure}

\newpage

\section{Description et conception des états}

\subsection{Description des états}

Un état de jeu est constitué d'une carte sur lequel se situent différents empires avec leurs différents bâtiments (éléments fixes), les éléments de décor (éléments fixes) et des unités de combats (éléments mobiles).

\subsubsection{Description de la carte}

La carte est représentée avec une grille composée de cases contenant des éléments sur chacunes d'elles avec une certaine position. Elle est composée d'empires, qui sont eux-mêmes constitués de bâtiments, et d'éléments comme les bâtiments, les unités de combats et les éléments de décor. Certains éléments sont franchissables par les unités et d'autres non. La taille de la carte est fixée.

\subsubsection{Description des états éléments fixes}

Les éléments fixes sont les décors et les bâtiments et les empires qui sont abstraits. Tous les éléments fixes possèdent une position (x,y) entre 0 et 24.\\

\uline{Décors}\\

Les décors sont de différents types: eau, herbe, dunes, montagnes, arbre, animaux... Ils ont chaucun un identifiant. Les décors possèdent un attribut passable qui permet de savoir si l'élément est franchissable ou non par les unités de soldats.\\

\uline{Empire}\\

Un empire a plusieurs attributs:
\begin{itemize}
\item un identifiant pour le différencier des autres empires (chiffre)
\item un nom
\item un niveau compris entre 1 et 4
\item des points de vie qui sont égaux à ceux du palais
\item des ressources (or, bois, nourriture) pour se développer et former des troupes
\item une liste de position permettant d'indiquer où se positionne l'empire sur la carte
\end{itemize}

Enfin, il est composée d'une caserne, d'un bâtiment ressource et enfin d'un palais. \\

\uline{Bâtiments}\\

Les bâtiments ont tous ces attributs :
\begin{itemize}
\item un identifiant pour le différencier des autres (chiffre)
\item un niveau qui va de 1 à 4
\item un coût en bois et en or pour les construire
\item un identifiant pour leur texture graphique
\end{itemize}

Il y a trois types de bâtiments: la caserne, les ressources et le palais.

La caserne a une capacité maximale de formation de troupes et possède comme attribut le nombre de troupes formées. Elle permet de former les différentes troupes.

Les ressources ont un niveau de production identique pour l'or, le bois ainsi que la nourriture. Ils vont permettre d'augmenter la richesse d'un joueur à chaque tour.

Le palais quant à lui possède des points de vie. C'est lui qui sera attaqué par un joueur et sa destruction mènera à la fin d'une partie.\\

Une carte de jeux typique sera composée de 25 x 25 cases disposées de manière isométrique. Ces cartes seront générées de manière aléatiores. 

\subsubsection{Description des états éléments mobiles}\\

Tous les éléments mobiles possèdent une position (x,y). 
Ils possèdent tous:
\begin{itemize}
\item un identifiant pour les différencier
\item un niveau de vie
\item un niveau de dommages en attaque
\item une portée pour attaquer
\itemun nombre de déplacements de cases limité
\item un coût en or et en nourriture pour la former
\item un identifiant de texture graphique.
\end{itemize}
Les unités de soldats dans le jeu sont les unités de combats: décurion, cavalier, catapulte et archer.\\

\subsection{Conception des états}
Dans cette partie nous allons décrire le diagramme UML d'état du jeu. (Voir figure 6)\\

Class "Element" : Cette classe est la classe mère de tous nos éléments, mobiles ou statiques. Nous avons choisi pour cette classe qu'elle contienne une position, la position de notre élément sur la map, et une méthode isPassable(), qui nous permet de savoir si l'élément peut être traversé par un autre.\\

Class "Units" : Cette classe est la classe mère de toutes nos unités mobiles sur la carte. Elle hérite d'"Element". Elle contient tous les paramètres nécessaires à la création d'une unité (vie, attaque, niveau, ...). Cette classe contitent de plus une méthode isPassable pour forcer le fait qu'on ne peut pas passer à travers une unité.\\

Class "Arrow" : Cette classe est la classe fille de Units. Elle hérite d'"Element". Elle permet de construire des unitées de type archer avec leurs attributs initialisés en fontion de leur niveau. Ce sera la façon la plus utilisée de créer un archer. Il existe de même des classes pour Decurion, Cavalier et Catapult.\\

Class "Buildings" : Cette classe est la classe mère de toutes nos unités statiques sur la carte. Elle hérite d'"Element". Elle contient tous les paramètres nécessaires à la création d'un bâtiment (niveau, coût, ...). Cette classe contitent de plus une méthode isPassable pour forcer le fait qu'on ne peut pas passer à travers un bâtiment.\\\\

Class "Barrack" : Une caserne est un bâtiment et hérite donc de "Buildings", elle ajoute en plus quelques fonctionnalitées telles que la création d'unités. De même pour les bâtiments de type ressource et palais.\\

Concernant les coûts, nous avons créé deux classes qui permettent de créer le coût des unités et des bâtiments, et de pouvoir les modifier.\\

Nous avons aussi choisi d'attribuer à chaque élément un id qui permet de savoir instantanément lequel il est.\\

Class "Decor" : Cette classe hérite d'élément, elle permet de créer les différents décors qui seront présents sur la carte de jeu.\\ 

Class "Empire" : Dans notre jeu nous avons besoin à tout instant d'avoir une classe qui stocke les éléments importants d'un empire. Par exemple un empire à un nom, une vie, de l'or, du bois, de la nourriture, ... . Ainsi, cette classe va agir comme un conteneur de tous les élements clés de notre empire.\\

Class "Map" : cette classe contient les éléments sur la carte de jeu. Elle permet d'ajouter des éléments, de les récupérer ou d'en supprimer. \\Nous avons procédé de la manière suivante : \begin{itemize}
    \item basicMap : ce tableau de "unique\_ptr" contient seulement des pointeurs de "Decor" de type herbe. Il s'agit de la carte de base sur laquelle va se supperposer le reste des textures. 
    \item decorMap : ce tableau de "unique\_ptr" va contenir tous les autres décors que l'herbe à savoir les forêts, les montagnes, les oceans et les animaux. 
    \item unitsMap : ce tableau de "unique\_ptr" contiendra les unités lorsqu'elles seront crées par nos observeurs. 
    \item buildingsMap : ce tableau de "unique\_ptr" contient tous les batiments des différents empires qui jouent. 
    \item selectedMap : ce tableau de "unique\_ptr" contient a chaque état du jeu, la ou les cases qui doivent être affichées en surbrillance pour aider le joueur. 
    \item statsMap : ce tableau de "unique\_ptr" contient les stats associées à chaques bâtiments, unités. 
    \item mapMatrix : ce tableau de "int" contient l'id de chaque type de bâtiments. Il nous permet de créer les autres tableaux pour éviter que les décors, les bâtiments, les unités se chevauchent.
\end{itemize}
Il y a ensuite un getter pour chacun de ces tableaux. \\Pour créer la map nous avons plusieurs possibilités : si on est en "record" on doit créer mapMatrix comme d'habitude mais l'enregistrer dans notre fichier JSON, si on est en "play" on remplit "mapMatrix" avec ce qui est enregistrée dans le JSON et, dans l'autre cas on créé la map normalement. \\

Class "Observable" : cette classe permet de réagir au des actions gérées par le moteur de jeu. Par exemple, lorsqu'un joueur souhaite améliorer un bâtiment ou créer une unité sur la carte de jeu, il faut que les cartes contenues dans notre classe Map soient modifées en conséquence.\\ Elle contient une méthode appelée "notifyObserveur" qui va notifier ses observeurs et une méthode "notifyObserveurPrev" pour notifier ses observeurs lors du rollback.  Cet observable est composé de deux observeurs : UnitsObserver et BuildingsObserver. NotifyObservers appelle ensuite le bon observeur en fonction des paramètre qu'on lui donne. La classe "Observable" contient de plus une méthode "getAllMaps" qui va permettre de récupérer les maps générées par le constructeur de Map. Par la suite, pour créer nos cartes de jeu initiales on créera une instance de "Obsevable". Elle contient aussi en attributs deux listes qui permettent de stocker les unités détruites (ressurectionUnits) ainsi que les empires détruits (ressurectionPalace) qui permettront de remettre ces éléments lors d'un rollback. A l'instanciation de cette classe nous allons pouvoir choisir si on souhaite enregistrer la partie (Record), rejouer la partie enregistrée (Play) ou jouer une nouvelle partie sans enregistrer. Dans les cas où nous souhaitons rejouer une partie ou en enregitrer une, l'observable appelle les méthodes "beginRecord" ou "beginReplay". Ces méthodes vont ensuite communiquer avec la class "Map" et lancer la construction de la carte de jeux en fonction de ce qu'on veut.\\

Class "UnitsObserver" : Cette classe est un Observer sur les Units. Elle va permettre de réaliser tous les changements nécessaires sur le state des units demandés par le moteur.

Class "BuildingsObserver" : Cette classe est un Observer sur les Buildings. Elle va permettre de réaliser tous les changements nécessaires sur le state des buildings demandés par le moteur.

\begin{figure}[!ht]
\centering
    \includegraphics[width=1\textwidth]{ressources/state.png}
     \caption{Diagramme de classes d'état}
\end{figure}

\newpage
\section{Rendu: Stratégie et conception des états}
\subsection{Stratégie de rendu d'un état}

Pour le rendu des états, nous avons décidé de faire une carte en 2D avec des tuiles et en isométrie. Cette carte sera à chaque fois générée aléatoirement et donc à chaque lancement du programme elle sera différente. Nous utilisons la librairie SFML. Nous avons trois tilesets qui vont nous servir à créer les textures de la carte: 
\begin{itemize}
\item un pour les textures du terrain (eau, herbe, animaux ...)
\item un pour les bâtiments (caserne, ressource, palais)
\item un pour les unités (archer, cavalier, decurion, catapulte)
\end{itemize}\\

Sur le côté gauche, un petit menu permet de donner le niveau, la vie et les dommages s'il y en a des éléments.

Nous aurons une carte divisée en quatre plans: 
\begin{itemize}
\item un pour l'herbe et l'eau qui sont nos éléments visuels de base
\item un pour les éléments de décor comme les montagnes, les arbres ou encore les animaux
\item un pour les bâtiments
\item un pour les unités mobiles
\end{itemize}\\

Les trois premiers plans seront initialisés au départ du jeu grâce aux textures et à des tableaux constitués des numéros de texture d'éléments, selon une position, générés aléatoirement, selon certaines règles de création de map:
\begin{itemize}
\item Toute la carte est préalablement constitué d'herbe seulement
\item Ensuite, trois zones d'eau sont tirées au sort aléatoirement
\item Puis, trois zones d'arbres et de montagnes sont tirées  aléatoirement et quelques animaux sont placés
\item Enfin, trois positions pour les empires sont tirées au sort et les trois bâtiments sont placés côte à côte
\end{itemize}\\

Tous les plans seront ensuite superposés pour former la carte. Les troix premiers plans seront fixes et seuls les plans des unités et des sélections des cases changeront. Ce dernier sera en effet modifié à chaque tour lorsque l'utilisateur fera déplacer ses unités mobiles. La mise à jour de l'affichage et du changement d'états se fera à une fréquence de quelques hertz.

\newpage

\begin{figure}[!ht]
\centering
    \includegraphics[width=1\textwidth]{ressources/MapAlea.png}
     \caption{Exemple d'un état généré aléatoirement}
\end{figure}

\subsection{Conception de rendu d'un état}
Dans cette partie nous allons décrire le diagramme UML de rendu d'un état du jeu.

Class "Tiles" : C'est un élément de base des tilesets. Ils ont une longueur et une largeur comme attributs ainsi qu'une position dans le tileset.\\

Class "TileSet" : Cette classe est la classe mère de tous les tilesets (tableaux de tuiles associés aux éléments). Elle est composée de tuiles. Nous avons choisi pour cette classe qu'elle contienne une méthode pour connaître la largeur d'une tuile et une autre qui permet de renvoyer la hauteur d'une tuile.\\

Class "BuildingTileSet" :  Elle hérite de "TileSet". Elle contient trois tableaux de tuiles comme attributs (un pour les casernes, un pour les palais et un pour les ressources) permettant de donner la texture associée à chaque élément. Elle possède une méthode permettant de renvoyer le chemin du fichier png contenant le tileset et une autre pour obtenir la tuile d'un bâtiment donné. \\

Class "DecorTileSet" :  Elle hérite de "TileSet". Elle contient un tableau de tuiles pour les décors comme attributs permettant de leur donner la texture associée. Elle possède une méthode permettant de renvoyer le chemin du fichier png contenant le tileset et une autre pour obtenir la tuile d'un décor donné. \\

Class "UnitsTileSet" :  Elle hérite de "TileSet". Elle contient quatre tableaux de tuiles comme attributs (un pour les archers, un pour les cavaliers, un pour les décurions et un pour les catapultes) permettant de donner la texture associée à chaque unité. Elle possède une méthode permettant de renvoyer le chemin du fichier png contenant le tileset et une autre pour obtenir la tuile d'une unité donnée. \\

Class "RenderMap" : Cette classe permet de créer une carte avec les textures d'un tileset. Elle constitue les plans d'une carte On empile ici les différents layers pour les différentes maps dans leur ordre de priorité. Cette classe contient des textures et un tableau en attributs. Elle permet d'ajouter une image de fond d'écran pour le jeu, de mettre à jour tous les layers et de les réaffficher à l'écran.\\
Cette classe contient aussi la méthode "handle" qui permet de gérer l'intéraction du joueur avec le rendu et d'envoyer les commandes correspondantes au moteur. Cette méthode utilise une méthode de récupération de click pour savoir où le joueur a cliqué sur l'écran et réagir en fonction.\\

Class "Layer" : Cette classe permet de créer des plans de carte. Elle est composée de RenderMap. Elle a comme attributs les tableaux de textures, selon leurs position, des éléments de base (herbe, eau), des décors et des bâtiments. Elle fait le lien entre la map du jeu contenue dans le diagramme d'état et le rendu. Elle a des méthodes qui permettent de charger un fichier de texture, de positionner un sprite sur une carte et lui donner sa texture et enfin d'afficher cette carte. Elle permet de plus d'initialiser le layer des stats qui affichent la vie, les ressources, les niveaux ainsi que le layer qui affiche les boutons lorsque le joueur a sélectionné une caserne pour créer une unité ou faire une amélioration de bâtiment. Cette classe nous permet aussi d'afficher du texte à l'écran.


\begin{figure}[!ht]
\centering
    \includegraphics[width=1\textwidth]{ressources/render.png}
     \caption{Diagramme de classes du rendu}
\end{figure}

\newpage
'
\newpage

\section{Règles de changements d'états et moteur de jeu}

\subsection{Horloge globale}
Tous les changements dans le jeu suivent une horloge globale pour le passage d'un état à un autre. \\
Ces changements sont réalisés en fonction du temps de passage d'un état à un autre. On attend la fin du changement d'état pour en réaliser un nouveau.

\subsection{Changements extérieurs}
Les changements extérieurs sont générés par des cliques du joueur. Les commandes sont les suivantes : 
\begin{itemize}
\item Cliquer sur n'importe quelle texture et consulter les actions qui lui sont associées ainsi que ses attributs (niveau de vie avec les coeurs, niveau, capacité ...).
\item Augmenter le niveau des bâtiments.
\item Créer des unités en séléctionnant leurs positions initiales avec un clique.
\item Déplacer des unités en choississant les cases parmi celles possibles.
\item Faire attaquer des unités entre elles.
\item Attaquer un hôtel de ville.
\end{itemize}

\subsection{Changements autonomes}
Ces changements sont ceux qui sont gérés par le moteur sans être provoqués par des actions utilisateurs
\begin{itemize}
\item Augmentation des ressources à chaque tour.
\item Disparition des unités qui n'ont plus de vie ainsi que de l'empire du palais n'ayant plus de vie.
\item Règles de mouvement et d'attaque.
\item Affichage des statistiques des bâtiments et des unités.
\end{itemize}


\subsection{Conception logiciel}
Le diagramme des classes du moteur est en figure 9 et diponible dans le dossier src du projet sous le nom de engine.
Dans cette étape de conception logiciel nous avons utilisé un pattern command. A son exécution, le moteur appelle des commandes en fonction des actions utilisateur. \\

\\Classes de commandes : Elles héritent toutes de la classe Command. Les commandes suivantes sont disponibles :
\begin{itemize}
\item Engine : cette classe contient quatre contener : \begin{itemize}
    \item CommandList : Ce conteneur contiendra la liste des commandes à exécuter. On met en queue toute les commandes qui doivent être exécutées lorsqu'un joueur (physique ou ia) veut réaliser une action.
    \item CommandListId : qui contient l'id de chaque commande mise en queue pour pouvoir caster ses comandes sur leurs bon types et les lancer. On empile et dépile en même temps dans ces deux conteneurs. 
    On empile et dépile en même temps dans ces deux conteneurs. 
    \item CommandListPrev : Ce conteneur contiendra la liste des commandes à exécuter. On met en deque toute les commandes qui doivent être exécutées lorsqu'un joueur (physique ou ia) veut réaliser un rollback.
    \item CommandListIdPrev : qui contient l'id de chaque commande mise en deque pour pouvoir caster ses comandes sur leurs bon types et les lancer. 
De plus, le moteur a un attribut text qui contient le numéro du joueur actuel ainsi que son action en cours. Cet attribut sera affiché lors du rendu.  
\end{itemize}
Engine a une méthode run qui permet de connaître le prochain joueur à jouer ainsi que la mise à jour des ressources à chaque fin de tour et savoir si la partie est terminée.
Engine contient de plus une méthode "execute" qui, tant que la queue n'est pas vide, exécute les actions et les dépiles. Dans le cas ou on a décidé d'enregistrer les commandes, elles sont ajoutées à une chaine de caractères et enregistrées au format JSON à l'exécution du destructeur. Le moteur a une méthode rollback qui permet de revenir à un état précédent. Méthode "replay" : cette méthode permet de lire toutes les commandes au format json et les ajouter à la FIFO de commandes. Ainsi, la méthode "execReplay" permet d'exécuter toutes les commandes empilées. 
\\Les différentes commandes sont les suivantes : 
    \begin{itemize}
        \item CaseIdentifier : Permet d'identifier la case sur laquelle on se trouve.
        \item Possibilities : Permet de déterminer quelles sont les actions possibles à partir de cette case.
        \item PrintStats : Affiche les stats (vie, niveau, bouttons) des joueurs et des bâtiments.
        \item LevelUp : Augmente le niveau d'un bâtiment.
        \item CreateUnit : Créer une unité à partir d'un premier clique sur une caserne. Le second clique permet de positionner l'unité crée sur la map. Des boutons seront disponibles pour choisir le type d'unités à créer.
        \item Move : Permet de déplacer une unité
        \item Attack : Permet d'attaquer une unité ou un hôtel de ville.
    \end{itemize}
\end{itemize}
Chaque commande a une méthode pour éxecuter et une méthode pour faire la commande inverse correspondante.
\begin{figure}[!ht]
\centering
    \includegraphics[width=1\textwidth]{ressources/engine.png}
     \caption{Diagramme de classes du moteur}
\end{figure}
\newpage
Voici une description de comment est implémenté le jeu grâce au moteur : \begin{itemize}
    \item On instancie un Observable qui instancie toutes les cartes de jeu.
    \item On instancie un objet pour actualiser le rendu. 
    \item On instancie le moteur pour pouvoir l'utiliser par la suite.
    \item On réalise le premier affichage de la map. 
    \item On ouvre une boucle qui tourne tant que la fenêtre est ouverte. C'est dans cette boucle que le jeu est réelement. 
    \item On met en place une logique de gestion de tours
    \item On appelle une méthode "handle" qui permet d'ajouter les actions du joueur en tant que commandes dans les listes de commandes du moteur. 
    \item On appelle la méthode execute du moteur qui exécute toutes les commandes contenues dans sa liste de commandes.
    \item On met à jour l'affichage. 
\end{itemize}
\newpage
\section{Intelligence artificielle}

\subsection{Stratégies}
\subsubsection{Intelligence aléatoire}
Cette stratégie est la même pour tous les empires. A chaque tour, chaque empire peut effectuer 3 actions : créer une unité, améliorer un bâtiment, déplacer une unité, attaquer un bâtiment ou une unité ennemie avec un de ses soldats. On choisit donc trois actions au hasard parmis celles-ci et on les effectue. 


\subsubsection{Intelligence basée sur des heuristiques}
Cette intelligence artificielle est basée sur des heuristiques que nous avons définies et qui, selon nos critères, doivent permettre de challenger un joueur humain.\\
Nous pensons en effet qu'un empire a, par exemple, intérêt à augmenter le niveau de ses bâtiments en fonction de ses moyens dès qu'il peut. Ensuite, l'empire devra créer des unités en fonction de ses capacités (nombre d'unités pouvant être formées pour chaque empire limité). Enfin, l'empire pourra  déplacer ses unités pour les mener à la conquête ou au combat. \\
Pour cela notre système intelligent va procéder comme suit en fonction de ses ressources et capacités de bâtiments : 
\begin{enumerate}
    \item Si l'empire a assez de ressources, l'AI doit améliorer son palace en premier (seul bâtiment pouvant se faire attaque).
    \item Améliorer la caserne qui permet d'améliorer les unités qui peuvent être formées. 
    \item Améliorer les ressources pour que la production à chaque tour soit augmentée.
    \item Créer une unité, le choix de l'unité à créer étant aléatoire.
\end{enumerate}
Une fois que ceci est fait nous gérons la partie mobile de notre jeu.\\Voici comment se décompose le système de déplacement et d'attaque de nos unités.
\begin{enumerate}
    \item Si une unité ennemie se situe à coté d'une unité de l'empire, on choisit cette unité et l'unité ennemie est attaquée.
    \item Si une unité de l'empire se situe à côté du Palace d'un empire ennemi, on choisit cette unité et, si elle est aussi à coté d'une unité ennemie elle attaque l'unité en priorité, sinon elle attaque le palace ennemi. Sinon : 
    \item On choisit une unité aléatoirement de l'empire courant. 
    \item Si elle se situe à moins de trois cases d'une unité ennemie, on s'en rapproche pour aller au combat.
    \item Sinon elle se rapproche de l'empire ennemi le plus proche. 
\end{enumerate}
Dans notre système, l'amélioration des bâtiments est privilégiée par rapport au déplacement ou attaques de nos unités. Si une unité d'un empire tombe au combat, cet empire pourra en créer une nouvelle en fonction de ses moyens au tour suivant.
\\Nous pouvons de plus remarquer qu'il y a parfois une unité qui ne va pas vers la bonne direction pendant au maximum 3 coups. Cela est dû à notre heuristique de déplacement qui dans un seul cas peut poser ce problème. Cependant cela arrive que très rarement et n'est pas pénalisant pour notre IA heuristique.

\subsubsection{Intelligence avancée}
Cette intelligence artificielle est basée sur des méthodes de résolution de problèmes à états finis. Pour cette intelligence artificielle nous avons choisi d'utiliser un algorithme de type min-max pour déterminer la meilleure action à réaliser. Ensuite, l'action déterminée par l'algorithme est réalisée avec l'heuristique de chaque action. Si l'action renvoyée par le min-max est un move, on appelle l'heuristique de move pour le réaliser... \\
Pour réaliser le min max nous avons dû limiter le nombre d'actions qu'il prend. En effet, nous avons 3 empires. Chaque empire peut réaliser 1 coup parmi 55 et ceux trois fois de suite. Ainsi, si on utilise toutes ces actions nous avons un nombre trop important de coups possibles et le temps de calcul pour optimiser une action serait très important.\\
Le min-max fonctionne de la façon suivante : 
\begin{enumerate}
    \item On fait réaliser à l'empire en cours une de ses actions possibles. 
    \item On fait réaliser à l'empire suivant une de ses actions possibles. 
    \item On fait réaliser au dernier empire une de ses actions possibles. 
    \item On actualise les poids
    \item A la fin de chaque action et actualisation des poids on effectue un rollback de l'action précédente pour ne pas que l'état soit modifié indéfiniemment.
\end{enumerate}
On itère ce processus pour toutes les actions possibles de chaque empire. Une fois que toutes les branches du dernier empire sont explorées, on fait remonter les poids en les minimisant au second empire à traiter. Une fois que toutes les branches du second empire sont explorées, on fait remonter les poids en les minimisant au premier empire à traiter. A la dernière étape, on maximise les poids pour maximiser l'influence du coup de l'empire 1 sur les deux autres. 
\\Lors de notre exploration des branches, celles qui ne sont pas réalisables ne sont pas explorées. Par exemple, lorsqu'il n'y a pas d'unités sur la map on n'essaie pas de faire de actions de type "move" ou "attack".
\\Cette intelligence avancée pourrait être très efficace si elle pouvait prévoir la meilleure chose à faire en fonction de toutes les actions de chaque tour de chaque empire possibles. Seulement, ceci serait bien trop long. Ainsi, le modèle proposé réalise une recherche sur un coup de chaque empire et ne prend pas en compte le fait qu'un empire peut réaliser 3 actions à chaque tour. 

Pour cette IA, un rollback, qui permet de revenir à un état précédent, a été implémenté afin de faire le min-max. Nous avons décidé de mémoriser les commandes dans un deque puis de dépiler la dernière lorsque le rollback est utilisé. Chaque commande a une méthode execute qui permet d'exécuter la commande et une méthode rollback qui permet de faire la commande inverse et ainsi revenir à l'état précédent.

\subsection{Conception logiciel}
\begin{itemize}
    \item Classe AI : qui sera la mère des trois différentes intelligences artificielles.
    \item Classe RandomAI : contient une méthode run qui permet à l'intelligence artificielle naïve de lancer ses coups. 
    \item Classe HeuristicAI : contient une méthode run qui permet à l'intelligence artificielle heuristique de lancer ses coups. Elle utilise les heuristiques définies dans la sous section précédente. Pour réaliser le déplacement des unités nous avons besoin d'une "mémoire". En effet, notre carte contient des obstacles. Ainsi, pour les contourner nous avons besoin à chaque mouvement de rechercher la case la plus proche de la cible mais qui n'implique ni un retour en arrière pénalisant ni d'être bloqué par un obstacle. Nous avons donc ajouté un attribut à la classe Units qui s'appelle "canMove" et qui stocke les 3 dernières cases utilisées par l'unité.
    \item Classe DeepAI : Contient une méthode "run" qui fait appel à une fonction minmax. Cette fonction minmax fait appel à une fonction min et une fonction max qui permettent de trouver le min ou le max d'une portion de tableau. La fonction min max réalise de plus des actions avec la méthodes preformActions puis elle les rollback et renvoie le meilleur coup à jouer à la méthode "run". Le poids de chaque action lorsqu'on est en bas de l'arbre est calculé par la fonction weightUpdate. Cette fonction permet de vérifier ce que peut faire le joueur et de renvoyer le poids de chaque action possible ou -1 dans le cas ou l'action ne peut pas être faite. Chaque action renvoie à une heuristique qui vérifie sa faisabilité et l'exécute ensuite. 
    \item Classe AStar : Cette classe permet d'utiliser l'algorithme AStar qui est un algorithme de recherche du plus court chemin entre deux points. Pour appliquer cette algorithme nous avons empêché que l'algorithme cherche à passer par des obstacles non franchissables.
\end{itemize}
\newpage

\begin{figure}[!ht]
\centering
    \includegraphics[width=1\textwidth]{ressources/ai.png}
     \caption{Diagramme de classes de l'ia}
\end{figure}

\newpage

\section{Modularisation}

\subsection{Organisation des modules}

\subsubsection{Serialisation des commandes}
L'objectif de cette partie est d'être capable d'enregistrer, si l'utilisateur le souhaite, l'ensemble des commandes et des statistiques de jeu de la partie en cours pour pouvoir la rejouer entièrement. Ceci n'est qu'une petite application de la sérialisation de commandes. En effet, son objectif principal est de pouvoir être utilisable par le serveur. La partie serveur de notre application est celle qui contiendra l'intégralité des calculs à savoir le moteur de jeu et les intelligences artificielles qui calculent les coups suivants. Ainsi, pour réaliser les commandes d'un joueur, il faut les envoyer au serveur. Le format utilisé est le format JSON. Il a été choisi pour sa simplicité d'écriture et de lecture. \\
Pour la partie "record" et "replay" nous devons :
\begin{itemize}
    \item Enregistrer la map aléatoire pour pouvoir la regénérer dans le "replay".
    \item Enregistrer toutes les commandes effectuées par les intelligences artificielles pour pouvoir les rejouer totalement.
\end{itemize}

Pour l'enregistrement général de notre partie, nous avons décidé d'utiliser un booléen à l'instanciation de notre observable qui dit si nous souhaitons faire un "record", un "replay" ou aucun des deux.\\
\\Partie "Record" :

Dans cette partie, nous enregistrons tout d'abord la map créée dans la classe "Map" de "State". Puis l'intégralité des commandes dans la classe "Engine" de "Engine". Pour cela, nous crééons une chaîne de caractère contenant les différentes instructions puis nous l'ajoutons au fichier JSON. L'écriture dans le fichier JSON de l'ensemble des commandes est fait dans le destructeur. Ainsi, il faut stopper l'exécution du code en fermant la fenêtre sfml et non en effectuant un "ctrl+c" dans le terminal. Pour réaliser le record il faut taper la commande : ./bin/client record.\\
\\Partie "Play" : 

Dans cette partie, nous lisons simplement le fichier au format JSON. Tout d'abord, dans le constructeur de la classe "Map" pour reconstituer la carte enregistrée. Puis, dans engine pour exécuter les commandes enregistrées une par une. Pour ceci, nous utilisons la bibliothèque "jsoncpp" qui permet de parser et de lire très facilement des données au format JSON. Cette partie se fait dans le moteur.

\subsubsection{Répartition sur différents threads}

L'objectif est de placer le rendu dans un thread principal et le moteur dans un thread séparé. 

Nous avons en tout quatre threads: 
\begin{itemize}
    \item thread principal: il permet d'initialiser au début les différentes variables, la fenêtre puis il gère l'affichage. Ce dernier est mis à jour dès que le moteur exécute une commande. Pour cela, le thread moteur envoie un signal pour informer au thread principal de rafraîchir le rendu.
    \item thread moteur: il exécute en permanence les commandes dès qu'il peut et émet un signal pour informer le thread principal de la mise à jour du rendu. 
    \item thread IA: il ajoute des commandes pour le joueur en cours. Il est exécuté après le thread secondaire.
    \item thread secondaire: il est exécuté avant le thread IA. Il permet de connaître le numéro du joueur à jouer et de faire les mises à jour des ressources.
    
\end{itemize}
Ces deux derniers threads ont un mutex en commun pour éviter l'utilisation de ressources critiques en même temps.
Nous devons mettre un certain délai entre l'éxecution des différentes commandes pour avoir un affichage et une exécution des commandes synchronisés.

\subsubsection{Répartition sur différentes machines : rassemblement des joueurs}
Comme expliqué précedemment, l'objectif global de la partie modularisation est de connecter différents joueurs à un réseau pour qu'ils puissent jouer ensemble. La première étape était de créer et de faire fonctionner la partie client de l'application de manière indépendante en multithread et de sérialiser les commandes. \\Dans cette partie, l'objectif est de créer la partie serveur de l'application et de s'y connecter par l'intermédiaire du client en exécutant des requêtes sur le serveur. Sur le serveur, nous allons écrire des APIs Web de type REST. Les services sont de type CRUD, ils doivent être capables de réaliser des ajouts, lectures, mises à jour et suppression dans des objets qui stockent temporairement les données de la partie en cours.\\Dans un premier temps, l'idée est de réaliser ces différentes requêtes sur un service qui gère les joueurs. Nous détaillerons par la suite le corps de ces requêtes : 


\begin{longtable}{ll}
   Requête GET /player/ &  \\
   \hline
   \hline
   Cas pas de données en entrée &  \\
   \hline
   Cas où il y a au moins un player & Statut OK\\
    & status: 200\\
    & type : "array"\\
    & body: \{ \\
    & \hspace{1cm}"players" : [\\
    &      \hspace{2cm}\{\\
    &          \hspace{3cm}"name" : \{type:string\},\\
    &          \hspace{3cm}"type" : \{type:number,ai:0,human:1\}\\
    &      \hspace{2cm}\},\\
    &      \hspace{2cm}\{\\
    &         \hspace{3cm}"name" : \{type:string\},\\
    &         \hspace{3cm}"type" : \{type:number,ai:0,human:1\}\\
    &      \hspace{2cm}\},\\
    &      \hspace{2cm}\{\\
    &         \hspace{3cm}"name" : \{type:string\},\\
    &         \hspace{3cm}"type" : \{type:number,ai:0,human:1\}\\
    &      \hspace{2cm}\}\\
    &   \hspace{1cm}]\\
    & \}\\
   \hline
    Cas où il n'y a pas de player & Statut OK\\
    & status: 200\\
    & type : "object"\\
    & body: \{ \\
    & \hspace{1cm}"players" : null\\
    & \}\\

    & & \\
    
   Requête GET /player/<id> &  \\
   \hline
   \hline
   Cas pas de données en entrée &  \\
   \hline
   Cas où il y a au moins un player & Statut OK\\
    & status: 200\\
    & type : "object"\\
    & body: \{ \\
    &      \hspace{1cm}\{\\
    &          \hspace{2cm}"name" : \{type:string\},\\
    &          \hspace{2cm}"type" : \{type:number,ai:0,human:1\}\\
    &      \hspace{1cm}\}\\
    & \}\\
   \hline
    Cas où il n'y a pas de player & Statut OK\\
    & status: 200\\
    & body: \{ \\
    & \hspace{1cm}null\\
    & \}\\

    & & \\
    
   Requête PUT /player &  \\
   \hline
   \hline
   Données en entrée &  \\
   \hline
    type : "object" & \\
   \{ & \\
    \hspace{1cm} "name" : \{type:string\}, & \\
    \hspace{1cm} "type" : \{type:number\} & \\
   \} & \\
   \hline
   Si place libre : & Status CREATED \\
   & Données sortie :\\ 
   & type : "object"\\
   & body: \{\\
   & \hspace{1cm} "id": \{type:number,minimum:1,maximum:3\},\\
   & \}\\
   \hline
   Si plus de place libre : & Status NOT\_CREATED \\
   & Données sortie :\\ 
   & Pas de données de sortie\\

   & & \\
    
   Requête POST /player/<id> &  \\
   \hline
   \hline
   Données en entrée &  \\
   \hline
    type : "object" & \\
   \{ & \\
    \hspace{1cm} "name" : \{type:string\}, & \\
    \hspace{1cm} "type" : \{type:number\} & \\
   \} & \\
   \hline
   Cas joueur <id> existe : & Status NO\_CONTENT \\
   & Pas de données en sortie\\
   \hline
   Cas joueur <id> n'existe pas : & Status NOT\_FOUND \\
   & Pas de données en sortie\\

   & & \\
    
   Requête DELETE /player/<id> &  \\
   \hline
   \hline
   Pas de données en entrée &  \\
   \hline
   Cas joueur <id> existe : & Status NO\_CONTENT \\
   & Pas de données en sortie\\
   \hline
   Cas joueur <id> n'existe pas : & Status NOT\_FOUND \\
   & Pas de données en sortie\\

\end{longtable}

\subsection{Conception logiciel}

Partie client : \\
La classe client a les attributs suivants:
\begin{itemize}
    \item un moteur
    \item une observable contenant les états du jeu
    \item le rendu
    \item une intelligence artificielle heuristique
    \item un mutex
\end{itemize}
La création d'un client permet donc d'avoir tous les éléments nécessaires pour faire tourner le jeu. 
La classe client a les méthodes suivantes:
\begin{itemize}
    \item le constructeur
    \item une méthode run: elle initialise les différentes variables, la fenêtre d'affichage et le thread principal. Elle lance aussi les différents threads.
    \item une méthode aiUpdating: elle permet de faire tourner l'IA 
    \item une méthode engineUpdating: elle permet d'exécuter les commandes et d'envoyer un signal pour mettre à jour le rendu
    \item une méthode playerUpdating qui met à jour le numéro du joueur à jouer ainsi que les ressources à chaque fin de tour
    \item une méthode connect : elle permet de tester la connexion au serveur. Ajouter un joueur à une partie, visualiser des joueurs, le supprimer. Cette méthode s'appuie sur les fonctions "sendPut", "sendDelete" et "sendGet" écrites pour éviter de dupliquer du code.
\end{itemize}

\newpage
Partie serveur : \\
Pour cette partie nous nous somme appuyés sur le td de moodle qui réalise un serveur REST très simple avec "microHTTPd". Nous avons fait le td et l'avons adapté à notre projet. \\Notre conception contient les éléments suivants : 

\begin{itemize}
    \item Méthode "main" : créée et lance le serveur microHTTPd.
    \item Classe "ServiceManager" : elle permet d'enregistrer de nouveaux services pour communiquer avec le serveur, de trouver les services correspondant aux routes appelées par les clients, et d'interroger ces services en fonction de la méthode qu'ils utilisent (GET, POST, PUT, DELETE).
    \item Classe Abstract Service : c'est cette classe qui permet au ServiceManager d'instancier n'importe quel service. Cette classe est une classe abstraite qui est héritée par tous les services de notre projet. Elle contient toutes les méthodes (CRUD) qui seront nécessaires à nos différents services et qui seront ré-implémentées grâce au principe du polymorphisme.  
    \item Classe "PlayerService" : Permet de réaliser les opérations de type CRUD sur la classe PlayerDB qui stocke dans un objet de type "map" les joueurs de la partie en cours. Un joueur est créé en instanciant un nouveau "Player" de la classe "Player". On peut ainsi ajouter, récupérer, modifier ou supprimer très facilement tous les joueurs contenues dans la "map" base de données.
    \item Classe "VersionService" : permet de connaître la version de l'API en cours. Ceci permet d'éviter des conflits entre versions. 
    \item Classe "ServiceException" : permet de déterminer et de renvoyer le bon statut à l'issue de chaque requête sur le serveur contenu dans l'énumeration "HttpStatus" ("OK, "BAD\_REQUEST", "CREATED"...).
\end{itemize}

\begin{figure}[!ht]
\centering
    \includegraphics[width=1\textwidth]{ressources/module.png}
     \caption{Diagramme de classes du client}
\end{figure}

\end{document}